# Lab 5: Copy on Write

##### 个人经验&避坑指南：
首先，关于usertrap函数，用uvmunmap()来删除页表项，并且用该函数自带的free功能来清除物理页，它会帮你调用你修改过的kfree。
不要自己调用kfree，那样会让不该free的东西（比如内核之类的）导致panic。

其次，copyout那里的判断条件，既不能write又不是COW的就返回-1，不能write但是是COW的就照搬usertrap那里的代码。

最后，usertrap那里，需要判断访问的virtual address是否超过MAXVA，超过的话就应该主动报错并setkill。（可以直接goto已有的代码部分）
（usertests里面的MAXVAPlus会检查这个！）

##### 官方提示[https://pdos.csail.mit.edu/6.828/2023/labs/cow.html]:

- 修改 uvmcopy() 以将父级的物理页面映射到子级，而不是分配新页面。对于设置了PTE_W的页面，清除子级和父级 PTE 中的PTE_W。(√)
- 修改 usertrap() 以识别页面错误。
  当原本可写的 COW 页发生写页错误时，使用 kalloc() 分配一个新页，将旧页复制到新页，并将新页安装到设置了PTE_W的 PTE 中。
  最初只读的页面（未映射PTE_W，如文本段中的页面）应保持只读状态并在父子之间共享；
  尝试写入此类页面的进程应该被终止。
- 确保每个物理页在最后一个 PTE 引用消失时被释放——但不是在此之前。
  实现此目的的一个好方法是为每个物理页保留引用该页的用户页表数量的“引用计数”。
  当kalloc()分配页面时，将页面的引用计数设置为 1 。
  当 fork 导致子进程共享页面时增加页面的引用计数，并在每次任何进程从其页表中删除页面时减少页面的计数。
  kfree()仅当其引用计数为零时才应将页面放回到空闲列表中。将这些计数保存在固定大小的整数数组中是可以的。
  您必须制定一个如何索引数组以及如何选择其大小的方案。
  例如，您可以使用页面的物理地址除以 4096 来索引数组，
  并为数组提供与 kalloc.c 中的kinit()放置在空闲列表上的任何页面的最高物理地址相同的元素数。
  请随意修改 kalloc.c （例如kalloc()和kfree()）以维护引用计数。
- 修改 copyout() 以在遇到 COW 页面时使用与页面错误相同的方案。

一些提示：

- 对于每个 PTE，有一种方法来记录它是否是 COW 映射可能会很有用。为此，您可以使用 RISC-V PTE 中的 RSW（为软件保留）位。
- usertests -q探索cowtest未测试的场景，因此不要忘记检查两者的所有测试是否都通过。
- 一些有用的宏和页表标志的定义位于kernel/riscv.h的末尾。
- 如果发生 COW 页面错误并且没有可用内存，则应终止该进程。
